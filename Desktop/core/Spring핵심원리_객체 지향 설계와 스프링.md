# 객체 지향 프로그래밍

- 추상화
- 캡슐화
- 상속
- 다형성

**장점** : 프로그램을 유연하고 변경이 용이하게 만듬 --> 컴포넌트를 쉽고 유연하게 변경하면서 개발할 수 있는 방법.

: 실세계와 객체 지향을 1:1로 매칭 X

: 역할과 구현으로 세상을 구분.

![스크린샷 2022-09-13 오후 12.32.53](/Users/hyunwoo/Library/Application Support/typora-user-images/스크린샷 2022-09-13 오후 12.32.53.png)

운전자를 바꾸지 않고도, 어떠한 자동차든지 새로 구현만 하면 자동차 역할로 넣어서 실행할 수 있음.

--> Client는 새로운 구현을 해도 쉽게 사용할 수 있음. 다른 대상으로 대체가 매우 용이함.

ex) 데이터를 수집하는 방법이 eAPI, gNMI, netconf, cli 여러가지가 있는데,

CollectService Interface에서 저 4개의 class 중 한개를 갈아끼면서 사용할수있음.

- 객체 설계시 역할(인터페이스) 를 먼저 부여하고, 그 역할을 수행하는 구현 객체 만들기.
- 혼자 있는 객체는 없다.
- 클라이언트 : 요청, 서버 : 응답

**다형성의 본질**

- 인터페이스를 구현한 객체 인스턴스를 실행 시점에 유연하게 변경할 수 있다.
- 다형성의 본질을 이해하려면 협력이라는 객체사이의 관계에서 시작해야함.
- 클라이언트를 변경하지 않고, 서버의 구현 기능을 유연하게 변경할 수 있다.

**역할과 구현을 분리**

- 실세계의 역할과 구현이라는 편리한 컨셉을 다형성을 통해 객체 세상으로 가져올 수 있음
- 유연하고, 변경이 용이
- 확장 가능한 설계 --> 객체를 한개 더 생성하면, 바로 client와 연결지을 수 있음.
- 클라이언트에 영향을 주지 않는 변경 가능
- **인터페이스를 안정적으로 잘 설계하는 것이 중요**

**역할과 구현을 분리하는것의 한계**

- 인터페이스 자체가 변하면, 클라이언트, 서버 모두에 큰 변경이 발생한다.

  ex) 자동차를 비행기로 변경해야하면?

**스프링과 객체 지향**

- 스프링은 다형성을 극대화해서 이용할 수 있게 도와준다.
- 제어의 역전(IoC), 의존관계 주입(DI) 은 다형성을 활용해서 역할과 구현을 편리하게 다룰 수 있도록 지원한다.
- 구현을 편리하게 변경할 수 있다.

## 좋은 객체 지향 설계의 5가지 원칙 (SOLID)

- ### SRP : 단일 책임 원칙 (single responsibility principle)

    - 한 클래스는 하나의 책임만 가져야 한다.
    - 변경이 있을 때 파급 효과가 적으면 단일 책임 원칙을 잘 따른것

- ### OCP : 개방-폐쇄 원칙 (Open/closed principle)

    - 확장에는 열려있으나, 변경에는 닫혀 있어야 한다. --> ex) 자동차를 확장 할수는 있지만, 역할이 변경되지는 않음.

    - 다형성을 활용.

    - 인터페이스를 구현한 새로운 클래스를 하나 만들어서 새로운 기능을 구현

      ```
      public class MemberService {
      //  private MemberRepository memberRepository = new MemoryMemberRepository();
      private MemberRepository memberRepository = new JdbcMemberRepository();
      }
      ```

    - 구현 클래스를 직접 선택 해줘야함. - 문제점.

        - 해결 방안?

      객체를 생성하고, 연관관계를 맺어주는 별도의 조립, 설정자가 필요하다.

      Spring이 해결.

- ### LSP : 리스코프 치환 원칙 (Liskov substitution principle)

    - 프로그램 객체는 ㅡ프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.

  예) 자동차 인터페이스의 엑셀은 앞으로 가라는 기능, 뒤로 가게 구현하면 LSP 위반, 느리 더라도 앞으로 가야함.

- ### ISP : 인터페이스 분리 원칙 (Interface segregation principle)

    - 특정 클라이언트를 위한 인터페이스 여러개가 범용 인터페이스 하나보다 낫다.

  자동차 인터페이스 -> 운전 인터페이스, 정비 인터페이스로 분리.

  사용자 클라이언트 -> 운전자 클라이언트, 정비사 클라이언트로 분리

  분리하면 정비 인터페이스 자체가 변해도 운전자 클라이언트에 영향을 주지 않음.

    - 인터페이스가 명확해지고, 대체 가능성이 높아진다.

- ### DIP : 의존관계 역전 원칙 (Dependency inversion principle)

    - 추상화에 의존해야지, 구체화에 의존하면 안된다. - 의존성 주입(DI) 은 이 원칙을 따르는 방법 중 하나.

    - 구현 클래스에 의존하지 말고, 인터페이스에 의존하라는 뜻

    - 장동건이 김태희랑만 연극 연습을 했다고해서, 김태희가 바뀐다고 연극을 못하는것은 말이 안됨.

      장동건이 줄리엣 역할인 사람과 연극을 연습한다고 생각. --> 인터페이스를 중요하게 생각.

#### 정리

- 객체 지향의 핵심은 다형성
- 다형성 만으로는 쉽게 부품을 갈이 끼우듯이 개발할 수 없다.
- 다형성 만으로는 구현 객체를 변경할 때 클라이언트 코드도 함께 변경된다.
- **다형성 만으로는 OCP, DIP를 지킬 수 없다.**
- 뭔가 더 필요하다.

## 객체 지향 설계와 스프링

- ### 스프링은 다음 기술로 다형성 + OCP, DIP를 가능하게 지원

    - DI(Dependency Injection) : 의존 관계, 의존성 주입
    - DI 컨테이너 제공

- **클라이언트 코드의 변경 없이 기능 확장**

## 정리

- ### 모든 설계에 **역할**과 구현을 분리.

- ### 자동차, 동연의 예를 떠올려보자.

- ### 어플리케이션 설계도 공연을 설계 하듯이 배역만 만들어두고, 배우는 언제든지 유연하게 변경할 수 있도록 만드는 것이 좋은 객체 지향 설계다.

- ### 이상적으로는 모든 설계에 인터페이스를 부여하자.

    - #### 실무 고민

        - 하지만 인터페이스를 도입하면 추상화라는 비용이 발생한다.
        - 기능을 확장할 가능성이 없다면, 구체 클래스를 직접 사용하고, 향후 꼭 필요할 때 리팩터링해서 인터페이스를 도입하는 것도 방법이다.