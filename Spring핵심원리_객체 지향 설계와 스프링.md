# 객체 지향 프로그래밍

- 추상화
- 캡슐화
- 상속
- 다형성

**장점** : 프로그램을 유연하고 변경이 용이하게 만듬 --> 컴포넌트를 쉽고 유연하게 변경하면서 개발할 수 있는 방법.

: 실세계와 객체 지향을 1:1로 매칭 X
: 역할과 구현으로 세상을 구분.

운전자를 바꾸지 않고도, 어떠한 자동차든지 새로 구현만 하면 자동차 역할로 넣어서 실행할 수 있음.

--> Client는 새로운 구현을 해도 쉽게 사용할 수 있음. 다른 대상으로 대체가 매우 용이함.

ex) 데이터를 수집하는 방법이 eAPI, gNMI, netconf, cli 여러가지가 있는데,

 CollectService Interface에서 저 4개의 class 중 한개를 갈아끼면서 사용할수있음.

- 객체 설계시 역할(인터페이스) 를 먼저 부여하고, 그 역할을 수행하는 구현 객체 만들기.
- 혼자 있는 객체는 없다.
- 클라이언트 : 요청, 서버 : 응답

**다형성의 본질**

- 인터페이스를 구현한 객체 인스턴스를 실행 시점에 유연하게 변경할 수 있다.
- 다형성의 본질을 이해하려면 협력이라는 객체사이의 관계에서 시작해야함.
- 클라이언트를 변경하지 않고, 서버의 구현 기능을 유연하게 변경할 수 있다.

**역할과 구현을 분리**

- 실세계의 역할과 구현이라는 편리한 컨셉을 다형성을 통해 객체 세상으로 가져올 수 있음
- 유연하고, 변경이 용이
- 확장 가능한 설계 --> 객체를 한개 더 생성하면, 바로 client와 연결지을 수 있음.
- 클라이언트에 영향을 주지 않는 변경 가능
- **인터페이스를 안정적으로 잘 설계하는 것이 중요**

**역할과 구현을 분리하는것의 한계**

- 인터페이스 자체가 변하면, 클라이언트, 서버 모두에 큰 변경이 발생한다.

  ex) 자동차를 비행기로 변경해야하면?

**스프링과 객체 지향**

- 스프링은 다형성을 극대화해서 이용할 수 있게 도와준다.
- 제어의 역전(IoC), 의존관계 주입(DI) 은 다형성을 활용해서 역할과 구현을 편리하게 다룰 수 있도록 지원한다.
- 구현을 편리하게 변경할 수 있다.

## 좋은 객체 지향 설계의 5가지 원칙 (SOLID)

- ### SRP : 단일 책임 원칙 (single responsibility principle)

    - 한 클래스는 하나의 책임만 가져야 한다.
    - 변경이 있을 때 파급 효과가 적으면 단일 책임 원칙을 잘 따른것

- ### OCP : 개방-폐쇄 원칙 (Open/closed principle)

    - 확장에는 열려있으나, 변경에는 닫혀 있어야 한다. --> ex) 자동차를 확장 할수는 있지만, 역할이 변경되지는 않음.
    - 다형성을 활용.
    - 인터페이스를 구현한 새로운 클래스를 하나 만들어서 새로운 기능을 구현
    - 사용영역의 변경은 닫혀있다 --> 사용영역은 변경 할 필요가 없이 구현 영역에서 다 변경한다.

    ```
    public class MemberService {
    //  private MemberRepository memberRepository = new MemoryMemberRepository();
    private MemberRepository memberRepository = new JdbcMemberRepository();
    }
    ```

  - 구현 클래스를 직접 선택 해줘야함. - 문제점.

      - 해결 방안?

    객체를 생성하고, 연관관계를 맺어주는 별도의 조립, 설정자가 필요하다.

    Spring이 해결.

- ### LSP : 리스코프 치환 원칙 (Liskov substitution principle)

    - 프로그램 객체는 ㅡ프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.

  예) 자동차 인터페이스의 엑셀은 앞으로 가라는 기능, 뒤로 가게 구현하면 LSP 위반, 느리 더라도 앞으로 가야함.

- ### ISP : 인터페이스 분리 원칙 (Interface segregation principle)

    - 특정 클라이언트를 위한 인터페이스 여러개가 범용 인터페이스 하나보다 낫다.

  자동차 인터페이스 -> 운전 인터페이스, 정비 인터페이스로 분리.

  사용자 클라이언트 -> 운전자 클라이언트, 정비사 클라이언트로 분리

  분리하면 정비 인터페이스 자체가 변해도 운전자 클라이언트에 영향을 주지 않음.

    - 인터페이스가 명확해지고, 대체 가능성이 높아진다.

- ### DIP : 의존관계 역전 원칙 (Dependency inversion principle)

    - 추상화에 의존해야지, 구체화에 의존하면 안된다. - 의존성 주입(DI) 은 이 원칙을 따르는 방법 중 하나.

    - 구현 클래스에 의존하지 말고, 인터페이스에 의존하라는 뜻

    - 장동건이 김태희랑만 연극 연습을 했다고해서, 김태희가 바뀐다고 연극을 못하는것은 말이 안됨.

      장동건이 줄리엣 역할인 사람과 연극을 연습한다고 생각. --> 인터페이스를 중요하게 생각.

#### 정리

- 객체 지향의 핵심은 다형성
- 다형성 만으로는 쉽게 부품을 갈이 끼우듯이 개발할 수 없다.
- 다형성 만으로는 구현 객체를 변경할 때 클라이언트 코드도 함께 변경된다.
- **다형성 만으로는 OCP, DIP를 지킬 수 없다.**
- 뭔가 더 필요하다.

## 객체 지향 설계와 스프링

- ### 스프링은 다음 기술로 다형성 + OCP, DIP를 가능하게 지원

    - DI(Dependency Injection) : 의존 관계, 의존성 주입
    - DI 컨테이너 제공

- **클라이언트 코드의 변경 없이 기능 확장**

## 정리

- ### 모든 설계에 **역할**과 구현을 분리.

- ### 자동차, 동연의 예를 떠올려보자.

- ### 어플리케이션 설계도 공연을 설계 하듯이 배역만 만들어두고, 배우는 언제든지 유연하게 변경할 수 있도록 만드는 것이 좋은 객체 지향 설계다.

- ### 이상적으로는 모든 설계에 인터페이스를 부여하자.

    - #### 실무 고민

        - 하지만 인터페이스를 도입하면 추상화라는 비용이 발생한다.
        - 기능을 확장할 가능성이 없다면, 구체 클래스를 직접 사용하고, 향후 꼭 필요할 때 리팩터링해서 인터페이스를 도입하는 것도 방법이다.

## 제어의 역전 IoC(Inversion of Control)

### OrderServiceImpl은 실행부분. 하지만 어떤 구현 객체들이 실행될지는 전혀 모르고, AppConfig가 모든 제어 흐름에 대한 권한을 가지고 있다.

### framework vs library
- 프레임워크가 내가 작성한 코드를 제어하고, 대신 실행하면 그것은 프레임워크가 맞다.
- 반면에 내가 작성한 코드가 직접 제어의 흐름을 담당한다면 그것은 프레임워크가 아니라 라이브러리다.

### 정적인 클래스 의존 관계
- 클래스가 사용하는 import 코드만 보고 의존관계를 쉽게 판단할 수 있다. 애플리케이션을 실행하지 않아도 알 수 있다.

![](../../../../../var/folders/w7/b20fft590_7cd_nb8x2htbl40000gn/T/TemporaryItems/NSIRD_screencaptureui_FwZ6ga/스크린샷 2022-09-16 오후 11.15.35.png)
--> OrderServiceImpl은 MemberRepository, DiscountPolicy를 의존하는것을 알수 있다.
하지만, 어떤 객체가 OrderServiceImpl에 의존되는지 알수가 없다. Fixed or Rate Discount인지를 알수가 없다.

### 동적인 클래스 의존 관계
- 애플리케이션 실행 시점에 실제 생성된 객체 인스턴스의 참조가 연결괸 의존 관계이다.
- 객체 다이어그램
- ![](../../../../../var/folders/w7/b20fft590_7cd_nb8x2htbl40000gn/T/TemporaryItems/NSIRD_screencaptureui_lpf4V8/스크린샷 2022-09-16 오후 11.22.00.png)
- 애플리케이션 **실행 시점(런타임)** 에 외부에서 실제 구현 객체를 생성하고, 클라이언트에 전달해서 클라이언트와 서버의 실제 의존관계가 연결 되는것을 **의존관계 주입** 이라고 한다.
- 객체 인스턴스를 생성하고, 그 참조 값을 연결해서 사용한다. - RateDiscountPolicy or FixedDiscountPolicy
- 의존 관계 주입을 사용하면 정적인 클래스의 의존관계를 변경하지 않고, 동적인 객체 인스턴스 의존관계를 쉽게 변경할수있다.
  - 정적 클래스 의존 관계의 맵을 전혀 손대지 않고도, 참조 값을 변경할수있음. 
  - OrderServiceImpl를 전혀 손대지않고, 
  - DiscountPolicy <-> FixedDiscountPolicy 를 동적인 객체로 바로 변경이 가능하다.
### IoC 컨테이너, DI 컨테이너
- AppConfig 처럼 객체를 생성하고 관리하면서 의존 관계를 연결해주는 것을 Ioc 컨테이너 또는 DI 컨테이너라 한다.
  - 최근에는 주로 DI 컨테이너라고 한다.
  - 또는 어셈블러, 오브젝트 팩토리 등으로 불리기도 한다.


## 스프링 컨테이너
- ApplicationContext 를 스프링 컨테이너라 한다.
- @Bean으로 Annotations이 적힌 메서드를 모두 호출해서 스프링 컨테이너에 등록한다. -> 등록된 객체 = 스프링 빈
- @Bean("name" = "") 으로 이름도 변경 가능. 기본값은 원래 메서드의 이름이다.
- 스프링 빈은 applicationContext.getBean(스프링 빈 이름, 스프링 빈 타입) 메서드를 사용해서 찾을 수 있다.

- 스프링 컨테이너를 사용하면 어떤 장점이 있을까?
### 스프링 컨테이너의 생성 과정
1. 스프링 컨테이너 생성
- 스프링 컨테이너를 생성할 떄는 구성 정보를 지정해주어야 한다.
- 여기서는 Appconfig.class 를 구성정보로 지정했다.
2. 스프링 빈 등록
- 스프링 컨테이너는 파라미터로 넘어온 설정 클래스 정보를 사용해서 스프링 빈을 등록한다.
- **빈 이름**
  - 빈 이름은 메서드 이름을 사용한다.
  - 빈 이름을 직접 부여할 수도 있다.
    - **주의: 빈 이름은 항상 다른 이름을 부여**해야한다.
3. 스프링 빈 의존관계 설정 - 준비
![](../../../../../var/folders/w7/b20fft590_7cd_nb8x2htbl40000gn/T/TemporaryItems/NSIRD_screencaptureui_3wtSRM/스크린샷 2022-09-17 오후 1.02.30.png)
4. 스프링 빈 의존관계 설정 -완료


## BeanFactory 와 ApplicationContext
- ### BeanFactory 
  - 컨테이너를 관리하는 최상위 인터페이스이다.
  - 빈을 관리하고 조회하는 역할을 담당.
- ### ApplicationContext
  - BeanFactory 기능을 모두 상속받아서 제공.
  - #### ApplicationContext가 제공하는 부가 기능
    - 메세지 소스를 활용한 국제화 기능
      - 한국에 들어오면 한국어, 영어권에서 들어오면 영어로 출력
    - 환경 변구
      - 로컬, 개발, 운영들을 구분해서 처리
    - 애플리케이션 이벤트
      - 이벤트를 발행가고 구독하는 모델을 편리하게 지원
    - 편리한 리소스 조회
      - 파일, 클래스패스, 외부 등에서 리소스를 편리하게 조회
  ### 정리
  - ApplicationContext는 BeanFactory의 기능을 상속받는다.
  - ApplicationContext는 빈 관리기능 + 편리한 부가 기능을 제공한다.
  -  BeanFactory를 직접 사용할 일은 거의 없다. 부가기능이 포함된 ApplicationContext를 사용한다. 
  - BeanFactory나 ApplicationContext를 스프링 컨테이너라 한다.

